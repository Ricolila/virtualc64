<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.10.0" xml:lang="en-US">
  <compounddef id="group__topic__state__mode" kind="group">
    <compoundname>topic_state_mode</compoundname>
    <title>State model</title>
    <innerclass refid="classvc64_1_1_thread" prot="public">vc64::Thread</innerclass>
    <innernamespace refid="namespacevc64">vc64</innernamespace>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__topic__state__mode_1ga2d45fe1f5a2e80dbc85acca426f26970" prot="public" static="no">
        <type>util::Exception</type>
        <definition>typedef util::Exception vc64::StateChangeException</definition>
        <argsstring></argsstring>
        <name>StateChangeException</name>
        <qualifiedname>vc64::StateChangeException</qualifiedname>
        <briefdescription>
<para>Requests a state change from within the emulator. </para>
        </briefdescription>
        <detaileddescription>
<para>This exception is thrown inside the emulator core when the CPU stops execution in the middle of frame. This happens when a breakpoint or watchpoint is hit, or when the CPU halts due to the execution of a jamming instruction </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/hoff/Retro/virtualc64/Emulator/Base/Thread.h" line="79" column="25" bodyfile="/Users/hoff/Retro/virtualc64/Emulator/Base/Thread.h" bodystart="79" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>This topic describes the state model of <ref refid="class_virtual_c64" kindref="compound">VirtualC64</ref>. </para>
    </briefdescription>
    <detaileddescription>
<para>After lauching, the emulator runs as a single thread alongside the GUI. The thread exists during the lifetime of the application, but may not compute new frames all the time. The exact behavior is controlled by the internal state.</para>
<para>The following states are distinguished:</para>
<para><itemizedlist>
<listitem><para><bold>Off:</bold> The emulator is turned off</para>
</listitem><listitem><para><bold>Paused:</bold> The emulator is turned on but not running</para>
</listitem><listitem><para><bold>Running:</bold> The emulator is turned on and running</para>
</listitem><listitem><para><bold>Suspended:</bold> The emulator is paused for a short period of time</para>
</listitem><listitem><para><bold>Halted:</bold> The emulator is shutting down</para>
</listitem></itemizedlist>
</para>
<para><image type="html" name="thread.png"></image>
</para>
<para>The thread executes an infinite loop which periodically calls function vc64::Thread::execute. After each iteration, the thread is put to sleep to synchronize timing.</para>
<sect2 id="group__topic__state__mode_1autotoc_md1">
<title>Suspend / Resume</title><para>The Thread class provides a suspend-resume mechanism for pausing the thread temporarily. This functionality is utilized frequently by the GUI to carry out atomic operations that cannot be performed while the emulator is running. To pause the emulator temporarily, the critical code section can be embedded in a suspend/resume block like this:</para>
<para><programlisting><codeline><highlight class="normal">suspend();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Modify<sp/>the<sp/>internal<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">resume();</highlight></codeline>
</programlisting></para>
<para>It it safe to nest multiple suspend/resume blocks, but it is essential that each call to <ref refid="classvc64_1_1_thread_1a6545b249dacdb26eac8b104c07f3bbc2" kindref="member">suspend</ref> is followed by a call to Thread class <ref refid="classvc64_1_1_thread_1a294d7de030baf69ae6f96f9f6bfc8ba6" kindref="member">resume</ref>. As a result, the critical code section must not be exited in the middle, e.g., by throwing an exception. It is therefore recommended to use the <computeroutput>SUSPENDED</computeroutput> macro which is exit-safe. It is used in the following way:</para>
<para><programlisting><codeline><highlight class="normal">{<sp/><sp/>SUSPENDED</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Modify<sp/>the<sp/>internal<sp/>state,</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>return,<sp/>or<sp/>throw<sp/>an<sp/>exceptions<sp/>as<sp/>you<sp/>like</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="group__topic__state__mode_1autotoc_md2">
<title>Synchronization</title><para>The Thread class is responsible for timing synchronization. I.e., it has to ensure that the proper amount of frames are executed per second. To synchronize timing, the thread waits for an external wake-up signal. When the wake-up signal comes in (by calling <ref refid="classvc64_1_1_thread_1a4bf669b15db347f665f0459d18a90680" kindref="member">wakeUp</ref>, the thread computes the computes computes all missing frames. If the number of missing frames exceeds a threshold, the thread resynchronizes itself by calling resync.</para>
</sect2>
<sect2 id="group__topic__state__mode_1autotoc_md3">
<title>Warp mode</title><para>To speed up emulation (e.g., during disk accesses), the emulator may be put into warp mode. In this mode, timing synchronization is disabled causing the emulator to run as fast as possible.</para>
<para>Similar to warp mode, the emulator may be put into track mode. This mode is enabled when the GUI debugger is opend and disabled when the debugger is closed. In track mode, several time-consuming tasks are performed that are usually left out. E.g., the CPU tracks all executed instructions and stores the recorded information in a trace buffer. </para>
</sect2>
    </detaileddescription>
  </compounddef>
</doxygen>
